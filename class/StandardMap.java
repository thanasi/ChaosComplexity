/*<html><body><h2> Standard map simulation</h2>This applet implements the standard map, a poincare map of the kicked rotor dynamical system.  It has a position variable x and a momentum variable p.  The iterate of (x, p) is given by<ul>p<sub>i+1</sub> = p<sub>i</sub> + r sin(2&pi; x<sub>i</sub>)<p>x<sub>i+1</sub> = (x<sub>i</sub> + p<sub>i+1</sub>) mod(1)</ul>The horizontal axis is x; the vertical axis is p.  p goes from -1 to +1.  If you click "compute" the applet chooses five initial points at random and propagates them n steps using the standard map.  The marks on the right indicate where p = 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5 and 1.  These values of p have motion commensurate with the driving kicks when r = 0. <ul><li> It is instructive to start from a low value of r and watch limit cycles and chaotic bands develop as r increases.  <li> You can set the momentum of the red trajectory.  It is initially set to the golden mean.  Its initial x value is set to 1/2.<li> Values are read from the input windows automatically when you click "Compute" You don't have to click "read values".  Note that p is not forced to lie between any limits, and so it may not always be plotted.</ul><applet	code="StandardMap.class",	archive="/java/jars/jcommon.jar, /java/jars/jfreechart.jar, /java/jars/P251Applet.jar",	 width=950, height=800></applet></body></html><pre>*///    StandardMap.java plots attractors of standard map starting from random points// in the x-p plane.  2010 edition: T. Witten//import java.awt.*;//import java.awt.event.*;//import java.lang.*;//import java.applet.Applet;import javax.swing.*;import P251.*;import java.awt.Color;public class StandardMap extends P251Applet {  final double pmax=1., xmax=1.;   double r= 0.020, pRED = 0.; int nstep=0, n=100;   Point[] z = new Point[6];    final static Color[] COLORS = {Color.RED, Color.ORANGE, Color.darkGray, Color.GREEN, Color.BLUE, Color.MAGENTA};   drawPanel2 dp;    inputPanel ip;	public void fillPanels() // specifies and outputs the drawing panel object to the applet	{        	dp = new drawPanel2(900,700); // creates the drawPanel object that will contain the drawing information		dp.setDrawBounds((float)0., (float)-.5, (float)1., (float)1.);        	addPanel(dp);		ip = new inputPanel();		ip.addField("red momentum =", pRED);				ip.addField("coupling r", r);		ip.addField("# of steps", n); 		ip.addField("now at ", nstep);		addPanel(ip);	} // end of fillPanels	public void initValues() {  //initializes x, p points of the trajectories to be followed		z[0] = new Point( .5, 2./(1. + Math.sqrt(5.))); //red trajectory has golden mean momentum		ip.setValue(0, z[0].p);		for (int i=1; i<z.length; i++) {z[i] = new Point(Math.random(), Math.random());}		nstep = 0;	} //end of initValues	public void readValues() { // read red momentum, r and n from input fields		z[0].p = ip.getValue(0);		r = ip.getValue(1);		n = (int)ip.getValue(2);	} //end of readValues	public void compute() {		readValues();		int nlast=nstep+n;		while(nstep<nlast) {			nstep++;			for (int i=0; i<z.length; i++) {				z[i].iterate(1);				dp.addLine((float)z[i].x, (float)z[i].p,(float)z[i].x, (float)z[i].p+.001,  COLORS[i]);			}		if (Thread.interrupted()) { return; }				if (((nlast - nstep) % 500) == 0) { //update display every 500 steps			ip.setValue(3, nstep);			ip.setValue(0, z[0].p);			putmarks();						dp.repaint();			try{Thread.sleep(300);}			catch(InterruptedException e) { 				System.out.println("there was an error sleeping");				return;			} //end of catch		} // end of if for updating		} //end of while 	} //end of compute//------methods used for computing and plotting	void putmarks() {  //marks rational values of p on the right side of the screen.		final float X0 = (float).1;		dp.addLine((float)1., (float)0. , (float)(1.-X0) ,(float)0.);		dp.addLine((float)1., (float)1. , (float)(1.-X0) ,(float)1.);				dp.addLine((float)1., (float).5, (float)(1.-.5*X0) , (float).5);		dp.addLine((float)1., (float).25, (float)(1.-.25*X0) ,(float).25);		dp.addLine((float)1., (float).75, (float)(1.-.25*X0)  , (float).75);		dp.addLine((float)1., (float).333, (float)(1.-.333*X0)  , (float).333);		dp.addLine((float)1., (float).667, (float)(1.-.333*X0)  , (float).667);		dp.addLine((float)1., (float).2, (float)(1.-.2* X0)  , (float).2);		dp.addLine((float)1., (float).4, (float)(1.-.2*X0)  , (float).4);		dp.addLine((float)1., (float).6, (float)(1.-.2*X0)  , (float).6);		dp.addLine((float)1., (float).8,  (float)(1.-.2*X0)  , (float).8);	}	private class Point extends Object  {  //single x, p point.		public double x, p; 		Point() {x = 0.; p = 0.;} 		Point(double xx, double pp) {x = xx; p = pp;}		public void iterate(int maxiter) {  //iterates x, p acording to Standard Map.			for (int iter= 1; iter<=maxiter; iter++) {				p = p + r *Math.sin(2.*Math.PI * x);				x = x + p; 				while(x > 1.) {x--;}  //assures that 0 < x < 1				while(x < 0.) {x++;}			} //end of iter loop		} //end of iterate 	}} // end of StandardMap	