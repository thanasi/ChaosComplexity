abstract class DiffEqSystem      {   //  abstract means that we can't //  make any instances of this class--not surprising since we don't //  yet know what differential equations we are going to solve   protected   VariableSet myvars;   protected int n_var;     //  \# of degrees of freedom: defined in SUBCLASS   protected double dt, dt2;      //  dt = time step; dt2 = dt/2//  constructor    DiffEqSystem()   {   //  don't know about variables yet, so just set time step:      setdt(0.3);   }   public   VariableSet nextvars()   {   //  method that returns next   VariableSet      return new   VariableSet(myvars.gettime()+dt, newx_rk4());                     //  4th order Runge-Kutta   }      public abstract double[] timederiv(double t, double[] x) ;   //  abstract method                  //  does nothing; actual timederiv to be defined in subclass      //  2nd order Runge-Kutta for time evolution   private double[] newx_rk2()   {      double x[] = myvars.getx();      double t = myvars.gettime();      double [] xtemp2 = new double[ n_var];      //  xtemp2 is estimate of x halfway along interval where taking      //  derivative leads to higher order error      xtemp2 = arraysum(x, mult_by_cst(timederiv(t, x), dt2));            return arraysum(x, mult_by_cst(timederiv(t + dt2, xtemp2), dt));   }      //  4th order Runge-Kutta for time evolution   //  formula from p 551 of Numerical Recipes, or   //       at http://csep1.phy.ornl.gov/ode/node7.html   private double[] newx_rk4()   {         double t = myvars.gettime();      double x[] = myvars.getx();      double[] k1 = new double[ n_var ];      double[] k2 = new double[ n_var ];      double[] k3 = new double[ n_var ];      double[] k4 = new double[ n_var ];      double[] xsum = new double[ n_var ];            k1 = mult_by_cst(dt, timederiv(t, x));      k2 = mult_by_cst(dt,            timederiv(t + dt2, arraysum(x, mult_by_cst(k1, .5))));      k3 = mult_by_cst(dt,            timederiv(t + dt2, arraysum(x, mult_by_cst(k2, .5))));      k4 = mult_by_cst(dt,            timederiv(t + dt, arraysum(x, k3)));            for(int i=0; i<n_var; i++)   {         xsum[i] = x[i] + (1./6.)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]);      }      return xsum;   }//  a bunch of set and get methods:      public void setdt(double deltat)   {      dt = deltat;      dt2 = dt/2.;   }      public double getdt()   {return dt;}      public void setvars(  VariableSet v)   {      if (v.getx().length == n_var) myvars = v;      else System.out.println("setvars: Wrong number of variables: "+n_var+ " should be "+v.getx().length );   }      public   VariableSet getvars()   {      return myvars;   }      public void settime(double time)   {      myvars.settime(time);   }      public double gettime()   { return myvars.gettime();   }      //  some useful utility methods, used in Runge-Kutta methods:      public double[] mult_by_cst(double constant, double array[])   {      double[] temp = new double[ n_var ];      for(int i=0; i< n_var; i++)   {         temp[i] = array[i]*constant;      }      return temp;   }                        //  end of mult_by_cst      public double[] mult_by_cst(double array[], double constant)   {      return mult_by_cst(constant, array);   }                        //  end of mult_by_cst      public double[] arraysum(double array1[], double array2[])   {                           //  add two arrays of length n_var      double[] temp = new double[ n_var ];      for (int i=0; i< n_var; i++)   {         temp[i] = array1[i] + array2[i];      }      return temp;   }                        //  end of arraysum      }   //  end of class DiffEqSystem  